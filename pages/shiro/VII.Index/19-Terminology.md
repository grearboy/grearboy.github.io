# 19. Terminology 术语



请花 2 分钟来阅读和理解它——这很重要。真的。这里的术语和概念在文档的任何地方都被涉及到，它将在总体上大大简化你对Shiro 和安全的理解。

由于所使用的术语使得安全可能令人困惑。我们将通过澄清一些核心概念使生活更容易，你将会看到 Shiro API 是如何很好地反映了它们：

* **Authentication** 身份验证是验证 Subject 身份的过程——实质上是证明某些人是否真的是他们所说的他们是谁。当认证尝试成功后，应用程序能够相信该subject 被保证是其所期望的。
* **Authorization**授权，又称为访问控制，是决定一个 user/Subject 是否被允许做某事的过程。它通常是通过检查和解释 Subject的角色和权限（见下文），然后允许或拒绝到一个请求的资源或功能来完成的。
* **Ciphern**密码是进行加密或解密的一种算法。该算法一般依赖于一块被称为 key 的信息。基于不同的key 的加密算法也是不一样的，所有解密没有它是非常困难的。密码有不同的表现形式。分组密码致力于符号块，通常是固定大小的，而流密码致力于连续的符号流。对称性密码加密和解密使用相同的密钥（key），而非对称性加密使用不同的密钥。如果非对称性加密的密钥不能从其他地方得到，那么可以创建公钥/私钥对公开共享。
* **Credential**凭证是一块信息，用来验证 user/Subject 的身份。在认证尝试期间，一个（或多个）凭证与 Principals(s)被一同提交，来验证 user/Subject 所提交的确实是所关联的用户。证书通常是非常秘密的东西，只有特定的
user/Subject 才知道，如密码或 PGP 密钥或生物属性或类似的机制。
这个想法是为 principal 设置的，只有一个人会知道正确的证书来“匹配”该 principal。如果当前 user/Subject 提供了正确的凭证匹配了存储在系统中的，那么系统可以假定并信任当前user/Subject 是真的他们所说的他们是谁。信任度随着更安全的凭证类型加深（如，生物识别签名 > 密码）。
* **Cryptography**加密是保护信息不受不希望的访问的习惯做法，通过隐藏信息或将它转化成无意义的东西，这样没人可以理解它。Shiro 致力于加密的两个核心要素：加密数据的密码，如使用公钥或私钥的邮件，以及散列表（也称消息摘要），它对数据进行不可逆的加密，如密码。
* **Hash**散列函数是单向的，不可逆转的输入源，有时也被称为消息，在一个编码的哈希值内部，有时也被称为消息摘要。它通常用于密码，数字指纹，或以字节数组为基础的数据。
* **Permission**权限，至少按照 Shiro 的解释，是在应用程序中描述原始功能的一份声明并没有更多的功能。权限是在安全策略中最低级别的概念。它们仅定义了应用程序能够做“什么”。它们没有说明“谁”能够执行这些操作。权限只是行为的声明，仅此而已。
一些权限的例子：
	* 打开文件
	* 浏览'/user/list'页面
	* 打印文档
	* 删除'jsmith'用户
* **Principal**Principal 是一个应用程序用户（Subject）的任何标志属性。“标志属性”可以是任何对你应用程序有意义的东西——用户名，姓，名，社会安全号码，用户ID 等。这就是它——没什么古怪的。Shiro 也引用一些我们称之为Subject 的 primary principal 的东西。一个 primary principal 是在整个应用程序中唯一标识 Subject 的 principal。理想的 primary principal 是用户名或 RDBMS 用户表主键——用户 ID。对于在应用程序中的用户（Subject）来说，只有一个primary principal
* **Realm**Realm 是一个能够访问应用程序特定的安全数据（如用户，角色和权限）的组件。它可以被看作是一个特定安全的 DAO（Data Access Object）。Realm 将这些应用程序特定的数据转换成 Shiro 能够理解的格式，这样Shiro 反过来能够提供一个单一的易于理解的 Subject 编程API，无论有多少数据源存在或无论你的数据是什么样的应用程序特定的格式。 Realm 通常和数据源是一对一的对应关系，如关系数据库，LDAP 目录，文件系统，或其他类似资源。因此，Realm 接口的实现使用数据源特定的API 来展示授权数据（角色，权限等），如JDBC，文件IO，Hibernate 或JPA，或其他数据访问API。
* **Role**基于你对话的对象，一个角色的定义是可以多变的。在许多应用程序中，它充其量是个模糊不清的概念，人们用它来隐式定义安全策略。Shiro 偏向于把角色简单地解释为一组命名的权限的集合。这就是它——一个应用程序的唯一名称，聚集一个或多个权限声明。
这是一个比许多应用程序使用的隐式的定义更为具体的定义。如果你选择了你的数据模型反映Shiro 的假设，你会发现将有更多控制安全策略的权力。
* **Session**会话是一个在一段时间内有状态的数据，其上下文与一个单一的与软件系统交互的user/Subject 相关联。当 Subject 使用应用程序时，能够从会话中添加/读取/删除数据，并且应用程序稍后能够在需要的地方使用该数据。会话会被终止，由于user/Subject 注销或会话不活动而超时。对于那些熟悉 HttpSession 的，Shiro Session 服务于同一目标，除了Shiro 会话能够在任何环境下使用，甚至在没有Servlet 容器或EJB 容器的环境。
* **Subject**Subject 只是一个精挑细选的安全术语，基本上的意思是一个应用程序用户的安全特定的“视图”。然而 Subject 不总是需要反映为一个人——它可以代表一个调用你应用程序的外部进程，或许是一个系统帐户的守护进程，
在一段时间内执行一些间歇性的东西（如一个cron job）。它基本上是任何使用应用程序做某事的实体的一个代表。


## 为文档加把手

我们希望这篇文档可以帮助你使用 Apache Shiro 进行工作，社区一直在不断地完善和扩展文档，如果你希望帮助 Shiro 项目，请在你认为需要的地方考虑更正、扩展或添加文档，你提供的任何点滴帮助都将扩充社区并且提升 Shiro。

提供你的文档的最简单的途径是将它发送到用户[论坛](http://shiro-user.582556.n2.nabble.com/)或[邮件列表](http://shiro.apache.org/mailing-lists.html)

*译者注：如果对本中文翻译有疑议的或发现勘误欢迎指正，[点此](https://github.com/waylau/apache-shiro-1.2.x-reference/issues)提问。*
